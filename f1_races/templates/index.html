<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posicionamento de Carros na Pista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fundo escuro */
            color: #e2e8f0; /* Texto claro */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Evita barras de rolagem indesejadas */
        }
        .container {
            background-color: #2d3748; /* Fundo do container mais claro */
            border-radius: 1rem; /* Cantos arredondados */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            padding: 20px;
            width: 100%;
            max-width: 800px; /* Largura máxima para o container */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Para posicionamento de elementos internos */
        }
        canvas {
            background-color: #000; /* Fundo do canvas preto para a pista */
            border: 2px solid #4a5568; /* Borda para o canvas */
            border-radius: 0.75rem; /* Cantos arredondados para o canvas */
            display: block;
            touch-action: none; /* Previne o comportamento padrão do touch para panning/zooming */
            width: 100%; /* Largura fluida */
            max-width: 760px; /* Limite para o canvas */
            height: auto; /* Altura automática para manter a proporção */
            cursor: grab; /* Cursor de arrastar */
        }
        canvas.grabbing {
            cursor: grabbing; /* Cursor de arrastando */
        }
        h1 {
            font-size: 2.25rem; /* Tamanho do título */
            font-weight: 700; /* Negrito */
            margin-bottom: 1.5rem;
            color: #63b3ed; /* Cor azul para o título */
            text-align: center;
        }
        .circuit-name {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            color: #cbd5e0;
            text-align: center;
        }
        .info-text {
            font-size: 0.875rem;
            color: #a0aec0;
            margin-top: 1rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Posicionamento dos Carros na Pista</h1>
        <div class="circuit-name" id="circuitName">Circuito de Baku (Animado)</div>
        <canvas id="carCanvas"></canvas>
        <p class="info-text">
            Os carros agora se movem ao longo da pista! Use a roda do mouse para zoom.
            Clique e arraste para mover a pista. Em dispositivos móveis, use um dedo para arrastar e dois dedos para zoom (pinça).
        </p>
    </div>

    <script>
        const canvas = document.getElementById('carCanvas');
        const ctx = canvas.getContext('2d');
        const circuitNameDisplay = document.getElementById('circuitName');

        // Dados de exemplo para o posicionamento dos carros
        // 'progress' é a posição do carro ao longo do trackPath (0 a 1)
        // 'speed' é a velocidade de movimento ao longo do trackPath
        const carPositions = [
            { driverName: "Verstappen", color: "#0000FF", progress: 0, speed: 0.005 },
            { driverName: "Hamilton", color: "#00FF00", progress: 0.1, speed: 0.0048 },
            { driverName: "Leclerc", color: "#FF0000", progress: 0.2, speed: 0.0049 },
            { driverName: "Perez", color: "#FFFF00", progress: 0.3, speed: 0.0047 },
            { driverName: "Sainz", color: "#FF8800", progress: 0.4, speed: 0.0046 },
            { driverName: "Russell", color: "#00FFFF", progress: 0.5, speed: 0.0045 },
            { driverName: "Norris", color: "#FF00FF", progress: 0.6, speed: 0.0044 },
            { driverName: "Piastri", color: "#8800FF", progress: 0.7, speed: 0.0043 },
            { driverName: "Alonso", color: "#008800", progress: 0.8, speed: 0.0042 },
            { driverName: "Stroll", color: "#880000", progress: 0.9, speed: 0.0041 },
            { driverName: "Gasly", color: "#888800", progress: 0.95, speed: 0.004 },
            { driverName: "Ocon", color: "#008888", progress: 0.05, speed: 0.0039 },
        ];

        // Estado da transformação do canvas para zoom e pan
        const transform = {
            scale: 1,
            translateX: 0,
            translateY: 0
        };

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        let initialPinchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Coordenadas de referência para o traçado da pista (baseado em um canvas de 800x480)
        // Estes pontos definem a linha central que os carros seguirão.
        // Se a imagem de fundo tiver uma proporção ou escala diferente,
        // você precisará ajustar estes pontos para corresponder à imagem.
        const trackPathPoints = [
            { x: 125, y: 390 }, // Ponto de partida aproximado (entre curva 13 e 1)
            { x: 165, y: 305 }, // Curva 1
            { x: 220, y: 240 }, // Curva 1
            { x: 270, y: 220 }, // Curva 1
            { x: 530, y: 170 }, // Reta longa
            { x: 670, y: 140 }, // Curva 26
            { x: 720, y: 220 }, // Curva 26
            { x: 720, y: 300 }, // Curva 27
            { x: 670, y: 380 }, // Curva 27
            { x: 500, y: 435 }, // Reta de trás
            { x: 420, y: 430 }, // Curva 18
            { x: 360, y: 390 }, // Curva 18
            { x: 290, y: 370 }, // Reta curta
            { x: 230, y: 370 }, // Curva 13
            { x: 170, y: 390 }, // Curva 13
            { x: 125, y: 390 } // Volta ao início para fechar o loop
        ];

        // Variável para armazenar a imagem da pista
        let trackImage = new Image();
        // IMPORTANTE: Substitua este URL pela URL da sua imagem da pista.
        // Use uma imagem com fundo transparente ou que se encaixe bem no canvas.
        trackImage.src = './baku_track.png'; // Placeholder

        // Adiciona um listener para quando a imagem carregar
        trackImage.onload = () => {
            drawScene(); // Redesenha a cena assim que a imagem estiver carregada
        };
        trackImage.onerror = () => {
            console.error("Erro ao carregar a imagem da pista. Verifique o URL.");
            // Opcional: desenhar uma pista fallback ou uma mensagem de erro
            drawScene(); // Tenta desenhar mesmo sem a imagem
        };


        // Função para obter um ponto ao longo do caminho da pista
        // Isso é uma simplificação. Para curvas de Bézier reais, você precisaria de uma função mais complexa.
        // Para este exemplo, usaremos interpolação linear entre os pontos.
        function getPointAlongPath(progress) {
            const numPoints = trackPathPoints.length;
            if (numPoints < 2) return { x: 0, y: 0 };

            // Garante que o progresso esteja entre 0 e 1
            progress = Math.max(0, Math.min(1, progress));

            // Calcula qual segmento da pista o carro está
            const segmentLength = 1 / (numPoints - 1);
            const segmentIndex = Math.floor(progress / segmentLength);
            
            // Lida com o último segmento para fechar o loop
            const p1Index = segmentIndex;
            const p2Index = (segmentIndex + 1) % numPoints; // Loop de volta ao início

            const p1 = trackPathPoints[p1Index];
            const p2 = trackPathPoints[p2Index];

            // Calcula o progresso dentro do segmento atual
            const segmentProgress = (progress % segmentLength) / segmentLength;

            // Interpolação linear entre os pontos
            const x = p1.x + (p2.x - p1.x) * segmentProgress;
            const y = p1.y + (p2.y - p1.y) * segmentProgress;

            return { x, y };
        }

        // Função para redimensionar o canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = canvas.width * 0.6; // Proporção 16:10
            if (canvas.height > window.innerHeight * 0.7) {
                canvas.height = window.innerHeight * 0.7;
            }
            drawScene(); // Redesenha a cena após redimensionar
        }

        // Função para desenhar o circuito usando a imagem de background
        function drawTrack() {
            // Desenha a imagem da pista como background
            if (trackImage.complete && trackImage.naturalWidth > 0) {
                // Desenha a imagem para preencher todo o canvas
                ctx.drawImage(trackImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: se a imagem não carregar, desenha a pista aproximada
                ctx.fillStyle = '#333'; // Cor da pista
                ctx.strokeStyle = '#555'; // Cor da borda
                ctx.lineWidth = 4; // Largura da borda da pista

                // Coordenadas baseadas em um canvas de 800x480 para o traçado de Baku
                // Pista externa
                ctx.beginPath();
                ctx.moveTo(100, 400); // Perto da curva 13
                ctx.lineTo(150, 300); // indo para a curva 1
                ctx.bezierCurveTo(160, 250, 200, 200, 250, 200); // Curva 1
                ctx.lineTo(550, 150); // Reta longa
                ctx.bezierCurveTo(600, 140, 650, 150, 700, 200); // Curva 26
                ctx.bezierCurveTo(750, 250, 750, 350, 700, 400); // Curva 27
                ctx.lineTo(500, 450); // Reta de trás
                ctx.bezierCurveTo(450, 460, 400, 450, 350, 400); // Curva 18
                ctx.lineTo(250, 380); // Reta curta
                ctx.bezierCurveTo(200, 370, 150, 380, 100, 400); // Curva 13 (fechando)
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Pista interna
                ctx.fillStyle = '#000'; // Cor do centro (fundo do canvas)
                ctx.beginPath();
                ctx.moveTo(150, 380); // Perto da curva 13 (interna)
                ctx.lineTo(180, 310); // indo para a curva 1 (interna)
                ctx.bezierCurveTo(190, 270, 230, 230, 280, 230); // Curva 1 (interna)
                ctx.lineTo(520, 180); // Reta longa (interna)
                ctx.bezierCurveTo(560, 170, 600, 180, 650, 230); // Curva 26 (interna)
                ctx.bezierCurveTo(680, 270, 680, 330, 650, 370); // Curva 27 (interna)
                ctx.lineTo(480, 420); // Reta de trás (interna)
                ctx.bezierCurveTo(440, 430, 400, 420, 370, 380); // Curva 18 (interna)
                ctx.lineTo(280, 360); // Reta curta (interna)
                ctx.bezierCurveTo(230, 350, 180, 360, 150, 380); // Curva 13 (interna, fechando)
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Função para desenhar um carro e o nome do piloto
        function drawCar(x, y, driverName, color) {
            // Desenha a bolinha (carro)
            ctx.beginPath();
            ctx.arc(x, y, 8 / transform.scale, 0, Math.PI * 2); // Raio ajustado pelo zoom
            ctx.fillStyle = color; // Cor do carro
            ctx.fill();
            ctx.strokeStyle = '#fff'; // Borda branca
            ctx.lineWidth = 1 / transform.scale; // Largura da borda ajustada pelo zoom
            ctx.stroke();
            ctx.closePath();

            // Desenha o nome do piloto
            ctx.fillStyle = '#e2e8f0'; // Cor do texto (branco claro)
            ctx.font = `bold ${14 / transform.scale}px Arial`; // Tamanho da fonte ajustado pelo zoom
            ctx.textAlign = 'center'; // Alinhamento centralizado
            ctx.textBaseline = 'bottom'; // Posição base do texto
            ctx.fillText(driverName, x, y - (12 / transform.scale)); // Posição do texto ajustada pelo zoom
        }

        // Função principal de desenho
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

            ctx.save(); // Salva o estado atual do contexto

            // Aplica as transformações de pan e zoom
            ctx.translate(transform.translateX, transform.translateY);
            ctx.scale(transform.scale, transform.scale);

            drawTrack(); // Desenha o circuito (agora com imagem)

            // Desenha cada carro e seu nome
            carPositions.forEach(car => {
                // Obtém a posição x, y do carro ao longo do caminho da pista
                const { x, y } = getPointAlongPath(car.progress);

                // As coordenadas dos carros são baseadas em um canvas de referência (800x480)
                // e são escaladas para o tamanho atual do canvas antes de aplicar o zoom/pan.
                const originalCanvasWidth = 800; // Largura de referência para os dados X
                const originalCanvasHeight = 480; // Altura de referência para os dados Y
                
                const scaledX = (x / originalCanvasWidth) * canvas.width;
                const scaledY = (y / originalCanvasHeight) * canvas.height;

                drawCar(scaledX, scaledY, car.driverName, car.color);
            });

            ctx.restore(); // Restaura o estado anterior do contexto
        }

        // --- Funções de Interatividade (Zoom e Pan) ---

        // Zoom com a roda do mouse
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Impede a rolagem da página

            const scaleAmount = 1.1; // Fator de zoom
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;

            // Calcula a posição do mouse no canvas antes do zoom
            const worldX = (mouseX - transform.translateX) / transform.scale;
            const worldY = (mouseY - transform.translateY) / transform.scale;

            if (e.deltaY < 0) { // Zoom in
                transform.scale *= scaleAmount;
            } else { // Zoom out
                transform.scale /= scaleAmount;
            }

            // Limita o zoom para evitar que fique muito pequeno ou muito grande
            transform.scale = Math.max(0.2, Math.min(5, transform.scale));

            // Ajusta a translação para manter o ponto do mouse no mesmo lugar
            transform.translateX = mouseX - worldX * transform.scale;
            transform.translateY = mouseY - worldY * transform.scale;

            drawScene();
        });

        // Pan com o mouse
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.classList.add('grabbing'); // Adiciona classe para mudar o cursor
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                transform.translateX += deltaX;
                transform.translateY += deltaY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                drawScene();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.classList.remove('grabbing'); // Remove classe do cursor
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.classList.remove('grabbing');
        });

        // Pan e Zoom com toque (Touch Events)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Previne o comportamento padrão do navegador (ex: rolagem)
            if (e.touches.length === 1) {
                // Um dedo para pan
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Dois dedos para pinch-to-zoom
                isDragging = false; // Desativa o pan de um dedo
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Previne o comportamento padrão do navegador
            if (e.touches.length === 1 && isDragging) {
                // Pan com um dedo
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - lastTouchX;
                const deltaY = touchY - lastTouchY;
                transform.translateX += deltaX;
                transform.translateY += deltaY;
                lastTouchX = touchX;
                lastTouchY = touchY;
                drawScene();
            } else if (e.touches.length === 2) {
                // Pinch-to-zoom com dois dedos
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);

                if (initialPinchDistance) {
                    const scaleFactor = currentPinchDistance / initialPinchDistance;
                    const oldScale = transform.scale;
                    transform.scale *= scaleFactor;

                    // Limita o zoom
                    transform.scale = Math.max(0.2, Math.min(5, transform.scale));

                    // Ajusta a translação para o centro dos toques
                    const midX = (touch1.clientX + touch2.clientX) / 2 - canvas.getBoundingClientRect().left;
                    const midY = (touch1.clientY + touch2.clientY) / 2 - canvas.getBoundingClientRect().top;

                    transform.translateX = midX - ((midX - transform.translateX) / oldScale) * transform.scale;
                    transform.translateY = midY - ((midY - transform.translateY) / oldScale) * transform.scale;

                    initialPinchDistance = currentPinchDistance; // Atualiza a distância inicial para o próximo movimento
                    drawScene();
                }
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = 0;
        });


        // Inicia a visualização quando a janela carregar
        window.onload = function() {
            resizeCanvas(); // Define o tamanho inicial do canvas
            window.addEventListener('resize', resizeCanvas); // Redimensiona ao mudar o tamanho da janela
            requestAnimationFrame(animateCars); // Inicia a animação dos carros
        };

        // Função de animação principal
        function animateCars() {
            // Atualiza a posição de cada carro
            carPositions.forEach(car => {
                car.progress += car.speed;
                if (car.progress >= 1) {
                    car.progress = 0; // Reinicia o carro para uma nova volta
                }
            });
            drawScene(); // Redesenha a cena com as novas posições
            requestAnimationFrame(animateCars); // Chama a próxima animação
        }
    </script>
</body>
</html>
